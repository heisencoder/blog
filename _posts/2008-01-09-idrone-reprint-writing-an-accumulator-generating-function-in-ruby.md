---
title: "iDrone reprint: Writing an accumulator generating function in Ruby"
date: 2008-01-09 20:26:00 +0000
categories:
  - Programming
  - iDrone
blogger_orig_url: /2008/01/idrone-reprint-writing-accumulator.html
---

[This is an iDrone reprint, Written by Mark W on Feb 9th, 2007]<br /><br />Talking with Matt, this morning, our conversation turned to the very large differences in power between various programming languages. While most would readily agree that higher level programming languages are far more expressive than assembly, many people draw the line there. Java, C++, VB, Python, Fortran are all “about the same” to quite a few people, including ,unfortunately, most of my previous bosses.  <p>One example Paul Graham <a target="_blank" href="http://www.paulgraham.com/icad.html">used</a> to illustrate differences between higher level programming languages is how difficult it is to write a function that generates accumulators— a function that takes a number n as a parameter, and returns a function that takes another number i and returns n + i.</p>  <p>In Python, he said the commonly accepted solution was as follows:<br /></p><p><code></code></p><blockquote><p><code><pre name="code" class="python">def foo(n):<br /> class acc:<br />   def __init__(self, s):<br />     self.s = s<br />    def inc(self, i):<br />      self.s += i<br />      return self.s<br />  return acc(n).inc </pre></code></p>  <p></p></blockquote><p>In Javascript, a surprisingly powerful language, considering it’s almost completely ignored outside of web page development, the solution is shorter and cleaner:<br /></p><p><code></code></p><blockquote></blockquote><p></p><blockquote><p><code><pre name="code" class="javascript"><br />function acc(n) {<br />  return function (i) {             <br />    return n += i <br />  } <br />}</pre></code></p>  <p></p></blockquote><p>One language Paul Graham did <i>not</i> mention, was Ruby. I’m still fairly new to Ruby, but the solution was not difficult. Due to the power of blocks in Ruby, this sort of functional programming is extremely clean. Here is the accumulator generating function: <code><br /></code></p><p><code></code></p><blockquote><p><code><pre name="code" class="ruby">def acc(n)<br />  lambda {|i| n += i}<br />end </pre></code></p>  <p></p></blockquote><p>Here’s a quick example of it in use: <code><br /></code></p><p><code></code></p><blockquote><p><code><pre name="code" class="ruby">f1 = acc(3)           # a function that increments by three<br />f1.call(5)            # returns 8<br />f1.call(-1)           # returns 2<br />f2 = acc(1.5)         # a function that increments by 1.5<br />f2.call(1)            # returns 2.5<br />f2.call(3)            # returns 4.5<br />f2.call(f1.call(1))   # returns 5.5 </pre></code></p>  <p></p></blockquote><p>In some less expressive languages, such as VB, C++, Fortran or Java, it isn’t even <i>possible</i><small><a target="_blank" href="http://www.idrone.net/2007/02/20/writing-an-accumulator-generating-function-in-ruby#1">[1]</a></small> to write a simple function that can generate accumulators.  Obviously since each of those languages are <a target="_blank" href="http://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>, the problem would be solvable, just not with a simple function. You could, given enough time, write a Ruby interpreter in C++, and then input <code><br /></code></p><p><code></code></p><blockquote><code><pre name="code" class="ruby">def acc(n)<br />  lambda {|i| n+i}<br />end</pre></code> </blockquote>to get your accumulator. <p></p><hr />  <p><small><a target="_blank" name="1">[1]</a>: Ken Anderson did offer an example of a way to kludge together an accumulator generating function in Java in Graham’s essay above. He used an integer to integer interface. Naturally enough, it fails to work for anything but integers. Generating a polymorphic function in Java, similar to the functions listed in this article would be a Sisyphean undertaking. If you can do it, I’d love to see a link to it in a comment.</small></p>